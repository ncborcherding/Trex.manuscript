---
title: Initital processing of SARS-COV2 Infection samples for Trex Manuscript
author: 
- name: Nick Borcherding
  email: ncborch@gmail.com
  affiliation: Washington University in St. Louis, School of Medicine, St. Louis, MO, USA
date: "August 19, 2020"
output:
  BiocStyle::html_document:
    toc_float: true

---

```{r, echo=FALSE, results="hide", message=FALSE}
knitr::opts_chunk$set(error=FALSE, message=FALSE, warning=FALSE)
library(BiocStyle)
```

# Introduction


##Computer Info:
Analysis is being run on a 13-inch Macbook Pro (2017) with 3.5 GHz Dual-Core i7 and 16 GB of 2133 MHz LPDDR3. There is a limit to the speed and RAM, so for the purposes of the markdown file, I will not run some of the code blocks during the kniting (look at eval = F). You will also see the call *rm()* frequently to just remove non-vital objects from the global environment.

***

# Loading Libraries

In general I like to load libraries here that we will use universally, and then call other libraries when we need them in the code chunks that are relevant. 

```{r}
suppressPackageStartupMessages(library(Seurat))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(gridExtra))
suppressPackageStartupMessages(library(viridis))
suppressPackageStartupMessages(library(scDblFinder))
suppressPackageStartupMessages(library(BiocParallel))
suppressPackageStartupMessages(library(Trex))

```

I also like to set a color palette before I begin - this way all the colors are consistent throughout the publication figures.

```{r setup, include=FALSE}
library(viridis)
colorblind_vector <- viridis_pal()(7)
```


***

# Loading and Processing the Data


## Load Data
```{r eval=FALSE}
dir.create("dataExplore")
dir.create("dataExplore/qc")
"%!in%" <- Negate("%in%")
file_list <- list.files("./data/SequencingRuns", pattern = "Sar")
list <- NULL
for (i in seq_along(file_list)){
    tmp <-  Read10X(paste0("./data/SequencingRuns/", file_list[i]))
    s.obj <- CreateSeuratObject(tmp$`Gene Expression`, project = file_list[i])
    row.index <- which(rownames(tmp$`Antibody Capture`) %!in% c("TCRVa7.2_TotalSeqC","TCRVa24Ja18_TotalSeqC"))
    
    adt_assay <- CreateAssayObject(counts = tmp$`Antibody Capture`[row.index,])
    
  
    # add this assay to the previously created Seurat object
    s.obj[["ADT"]] <- adt_assay
    s.obj <- RenameCells(object = s.obj, new.names = paste0(file_list[i], "_", rownames(s.obj[[]])))
    s.obj<- subset(s.obj, subset = nFeature_RNA > 100)
    s.obj[["mito.genes"]] <- PercentageFeatureSet(s.obj, pattern = "^MT-")
    
    p1 <- VlnPlot(object = s.obj, features = c("nCount_RNA")) + theme(legend.position = "none")
    p2 <- VlnPlot(object = s.obj, features = c("nFeature_RNA")) + theme(legend.position = "none")
    p3 <- VlnPlot(object = s.obj, features = c("mito.genes")) + theme(legend.position = "none")
    
    pdf(paste0("./dataExplore/qc/", file_list[i], ".pdf"), height = 8, width=12)
    grid.arrange(p1, p2, p3, ncol = 3)
    dev.off()
    
    ###########################
  #Here is the filtering step
  ############################
  standev <- sd(log(s.obj$nFeature_RNA))*2.5 #cutting off above standard deviation of 2.5
  mean <- mean(log(s.obj$nFeature_RNA))
  cut <- round(exp(standev+mean))
  s.obj <- subset(s.obj, subset = mito.genes < 10 & nFeature_RNA < cut)
    
   ###########################################
  #Estimate Doublets for Each Sequencing Run
  ############################################
  sce <- as.SingleCellExperiment(s.obj)
  sce <- scDblFinder(sce, BPPARAM=MulticoreParam(3))
  doublets <- data.frame(db.weight.score = sce$scDblFinder.score, db.ratio = sce$scDblFinder.weighted, 
                         db.class = sce$scDblFinder.class, db.score = sce$scDblFinder.score)
  rownames(doublets) <- rownames(sce@colData)
  s.obj <- AddMetaData(s.obj, doublets)
  rm(sce)
  
  ####Adding meta data
  directory <- readxl::read_xlsx("./data/sample.directory.xlsx") #Meta.data
  meta <- s.obj[[]]
  rownames <- rownames(meta)
  meta <- merge(meta, directory, by.x = "orig.ident", by.y = "ID")
  meta <- meta[,9:ncol(meta)]
  rownames(meta) <- rownames
  
  
  ## Finding variable features and normalizing data for integration to follow
  s.obj <- AddMetaData(s.obj, meta)
  s.obj <- NormalizeData(s.obj)
  s.obj <- FindVariableFeatures(s.obj, selection.method = "vst", nfeatures = 2000)
  s.obj <- quietTCRgenes(s.obj)
  VariableFeatures(s.obj, assay = "ADT") <- rownames(s.obj[["ADT"]])
  s.obj <- NormalizeData(s.obj, normalization.method = 'CLR', margin = 2, assay = "ADT")

  list[[i]] <- s.obj
}
saveRDS(list, file = "./data/filtered_seuratObjects.rds")
rm(tmp)
rm(adt_assay)
rm(s.obj)
```


## Integrate Assays

```{r}

#####################
#Integrating RNA
###################

# select features that are repeatedly variable across datasets for integration
features <- SelectIntegrationFeatures(object.list = list)

immune.anchors <- FindIntegrationAnchors(object.list = list, anchor.features = features)
# this command creates an 'integrated' data assay
immune.combined <- IntegrateData(anchorset = immune.anchors)
immune.combined <- ScaleData(immune.combined, verbose = FALSE)
immune.combined <- RunPCA(immune.combined, npcs = 30, verbose = FALSE)

saveRDS(immune.combined, file = "./data/RNAintegrated_seuratObjects.rds")
rm(features)
rm(immune.anchors)
rm(immune.combined)


############################
#Integrating ADT
############################
list <- readRDS("./data/filtered_seuratObjects.rds")
features <- rownames(list[[1]][["ADT"]])

list <- lapply(X = list, FUN = function(x) {
    DefaultAssay(x) <- "ADT"
    x <- ScaleData(x, features = features, verbose = FALSE)
    x <- RunPCA(x, features = features, verbose = FALSE)
})

ADT.anchors <- FindIntegrationAnchors(object.list = list, reference = c(1, 2), reduction = "rpca", 
    dims = 1:30, assay = rep("ADT", 14), anchor.features = 37)
ADT.integrated <- IntegrateData(anchorset = ADT.anchors, dims = 1:30)
ADT <- ADT.integrated@assays$integrated
rm(ADT.anchors)
rm(ADT.integrated)

############################
#Combining all to single object
############################
list <- readRDS("./data/RNAintegrated_seuratObjects.rds")
list[["ADT.integrated"]] <- ADT

DefaultAssay(list) <- 'ADT.integrated'
VariableFeatures(list) <- rownames(list[["ADT.integrated"]])
list <-  list %>% 
  ScaleData() %>% RunPCA(reduction.name = 'apca')

saveRDS(list, file = "./data/Fullintegrated_seuratObjects.rds")
```

# Initial UMAP and Clustering

```{r}
list <- readRDS("./data/Fullintegrated_seuratObjects.rds")

list <- FindMultiModalNeighbors(
  list, reduction.list = list("pca", "apca"), 
  dims.list = list(1:30, 1:30), modality.weight.name = "RNA.weight"
)

k <- c(15,20,25,30,35,40,45,50,55,60,65)
dir.create("./dataExplore/keval")
out <- NULL
for(i in k) {
  myClusterFUN <- function(x, k) {
      g <- bluster::makeSNNGraph(x, type="jaccard", k = k)
      igraph::cluster_louvain(g)$membership
  }
  
  pcs <- list@neighbors$weighted.nn@nn.dist
  originals <- myClusterFUN(pcs, i)
  
  set.seed(0010010100)
  ratios <- bluster::bootstrapStability(pcs, FUN=myClusterFUN, k = i, clusters=originals)
  dim(ratios)
  
  pdf(paste0("./dataExplore/keval/Heatmap_Cluster.stability", i, ".pdf"), height = 3, width = 3.25)
  pheatmap::pheatmap(ratios, cluster_row=FALSE, cluster_col=FALSE, fontsize = 4,
      color=viridis::magma(100), breaks=seq(-1, 1, length.out=101))
  dev.off()
  summary <- c(i, mean(diag(ratios), na.rm = TRUE), median(diag(ratios), na.rm = TRUE), sd(diag(ratios), na.rm = TRUE))
  out <- rbind(out, summary)
}
colnames(out) <- c("k", "mean", "median", "stdev")
write.csv(out, "./dataExplore/keval/ClusterPerformance.csv", row.names = FALSE)
```


```{r}
list <- ref_LCMV_Atlas_mouse_v1.rdsAP(list, 
                nn.name = "weighted.nn", 
                reduction.name = "wnn.umap", 
                reduction.key = "wnnUMAP_", 
                n.neighbors = 50)


res <- k <- c(0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.3, 1.4, 1.5)
for (i in seq_along(res)) {
  list <- FindClusters(list, graph.name = "wsnn", algorithm = 3, resolution = res[i], verbose = FALSE)
}
```

Evaluating clustering by resolution using clustree

```{r}
library(clustree)
clustree(list, prefix = "wsnn_res.", layout = "sugiyama")
ggsave("./dataExplore/ClusterTree_resolution.pdf", height = 12, width = 12)

clustree(list, prefix = "wsnn_res.", layout = "sugiyama", node_colour = "sc3_stability")
ggsave("./dataExplore/ClusterTree_stability.pdf", height = 12, width = 12)
```
Selecting the resolution of 0.8 based on the clustree results. 

```{r}
list@meta.data$seurat_clusters <- list@meta.data$wsnn_res.0.8
list@meta.data <- list@meta.data[,-grep("wsnn_res", colnames(list[[]]))]
Idents(list) <- "seurat_clusters"
DimPlot(list, label = TRUE) + NoLegend()
saveRDS(list, file = "./data/Fullintegrated_seuratObjects.rds")
```


#ProjecTIL annotation using the LCMV CD4 and CD8 data sets

```{r}
library(ProjecTILs)
list <- SplitObject(list, split.by = "orig.ident")
ref <- load.reference.map("./data/Annotation/ref_LCMV_CD4_mouse_release_v1.rds")
query.projected <- make.projection(list, ref = ref, ncores = 1, human.ortho = TRUE)

#Lapply across list of Seurat objects
query.projected <- lapply(query.projected, function(x) {
    cellstate.predict(ref = ref, query = x, reduction = "umap", ndim = 2)
})

CD4.annotation <- NULL
#Loop for the meta data
for (i in seq_along(query.projected)) {
  meta <- query.projected[[i]][[c("functional.cluster", "functional.cluster.conf")]]
  colnames(meta) <- c("CD4.annot", "CD4.score")
  rownames(meta) <- stringr::str_remove(rownames(meta), "Q_")
  CD4.annotation <- rbind(CD4.annotation, meta)
}
saveRDS(CD4.annotation,"./data/Annotation/CD4.annotation.rds")
rm(CD4.annotation)
rm(query.projected)


ref <- load.reference.map("./data/Annotation/ref_LCMV_Atlas_mouse_v1.rds")
query.projected <- make.projection(list, ref = ref, ncores = 1, human.ortho = TRUE)

#Lapply across list of Seurat objects
query.projected <- lapply(query.projected, function(x) {
    cellstate.predict(ref = ref, query = x, reduction = "umap", ndim = 2)
})

CD8.annotation <- NULL
#Loop for the meta data
for (i in seq_along(query.projected)) {
  meta <- query.projected[[i]][[c("functional.cluster", "functional.cluster.conf")]]
  colnames(meta) <- c("CD8.annot", "CD8.score")
  rownames(meta) <- stringr::str_remove(rownames(meta), "Q_")
  CD8.annotation <- rbind(CD8.annotation, meta)
}
saveRDS(CD8.annotation,"./data/Annotation/CD8.annotation.rds")
rm(CD8.annotation)
rm(query.projected)

```

## SingleR annotation using the DICE data set
```{r}
library(SingleR)
library(Matrix)
DICE.annotation <- NULL
for (i in seq_along(list)) {
  tmp <- list[[i]]
  tmp.2 <- tmp@assays[["RNA"]]@counts
  ####This approach for matrix conversion saves some memory
  tmp.2 <- tmp.2[tabulate(summary(tmp.2)$i) != 0, , drop = FALSE]
  tmp.2 <- as.matrix(tmp.2)
  com.res2 <- SingleR(tmp.2, ref=DICE, labels=DICE$label.fine, assay.type.test=1)
  df <- data.frame("DICE.first.labels" = com.res2$first.labels, "DICE.labels" = com.res2$labels, "DICE.pruned.labels" = com.res2$pruned.labels)
  DICE.annotation <- rbind(DICE.annotation, df)
}
```




# Annotation of Clusters

# Adding contig data to the Seurat object
```{r}
library(scRepertoire)
file_list <- list.files("./data/SequencingRuns", pattern = "Sar")
######################################
#iterate to make a list of contig csvs
######################################


contig.list <- NULL
for (i in seq_along(file_list)){
  contig.list[[i]] <-  read.csv(paste0("./data/SequencingRuns/", file_list[i], "/contig_annotations.csv"))
}
names(contig.list) <- file_list

##################################################
#Reducing the data to the individual barcode level
##################################################
combinedObject <- combineTCR(contig.list, samples = file_list, filterMulti = TRUE, removeNA = TRUE, cells = "T-AB")
combinedObject <- addVariable(combinedObject, name = "Patient", variables = substr(file_list, 1,5))
list <- combineExpression(combinedObject, list, cloneCall = "aa", groupBy = "Patient")
saveRDS(list, file = "./data/Filteredintegrated_seuratObjects.rds")
```





