---
title: Initital processing of SARS-COV2 Infection samples for Trex Manuscript
author: 
- name: Nick Borcherding
  email: ncborch@gmail.com
  affiliation: Washington University in St. Louis, School of Medicine, St. Louis, MO, USA
date: "August 19, 2020"
output:
  BiocStyle::html_document:
    toc_float: true

---

```{r, echo=FALSE, results="hide", message=FALSE}
knitr::opts_chunk$set(error=FALSE, message=FALSE, warning=FALSE)
library(BiocStyle)
```

# Introduction


##Computer Info:
Analysis is being run on a 13-inch Macbook Pro (2017) with 3.5 GHz Dual-Core i7 and 16 GB of 2133 MHz LPDDR3. There is a limit to the speed and RAM, so for the purposes of the markdown file, I will not run some of the code blocks during the kniting (look at eval = F). You will also see the call *rm()* frequently to just remove non-vital objects from the global environment.

***

# Loading Libraries

In general I like to load libraries here that we will use universally, and then call other libraries when we need them in the code chunks that are relevant. 

```{r}
suppressPackageStartupMessages(library(Seurat))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(gridExtra))
suppressPackageStartupMessages(library(viridis))
suppressPackageStartupMessages(library(scDblFinder))
suppressPackageStartupMessages(library(BiocParallel))
suppressPackageStartupMessages(library(Trex))

```

I also like to set a color palette before I begin - this way all the colors are consistent throughout the publication figures.

```{r setup, include=FALSE}
library(viridis)
colorblind_vector <- viridis_pal()(7)
```


***

# Loading and Processing the Data


## Load Data
```{r eval=FALSE}
dir.create("dataExplore")
dir.create("dataExplore/qc")
"%!in%" <- Negate("%in%")
file_list <- list.files("./data/SequencingRuns", pattern = "Sar")
list <- NULL
for (i in seq_along(file_list)){
    tmp <-  Read10X(paste0("./data/SequencingRuns/", file_list[i]))
    s.obj <- CreateSeuratObject(tmp$`Gene Expression`, project = file_list[i])
    row.index <- which(rownames(tmp$`Antibody Capture`) %!in% c("TCRVa7.2_TotalSeqC","TCRVa24Ja18_TotalSeqC"))
    
    adt_assay <- CreateAssayObject(counts = tmp$`Antibody Capture`[row.index,])
    
  
    # add this assay to the previously created Seurat object
    s.obj[["ADT"]] <- adt_assay
    s.obj <- RenameCells(object = s.obj, new.names = paste0(file_list[i], "_", rownames(s.obj[[]])))
    s.obj<- subset(s.obj, subset = nFeature_RNA > 100)
    s.obj[["mito.genes"]] <- PercentageFeatureSet(s.obj, pattern = "^MT-")
    
    p1 <- VlnPlot(object = s.obj, features = c("nCount_RNA")) + theme(legend.position = "none")
    p2 <- VlnPlot(object = s.obj, features = c("nFeature_RNA")) + theme(legend.position = "none")
    p3 <- VlnPlot(object = s.obj, features = c("mito.genes")) + theme(legend.position = "none")
    
    pdf(paste0("./dataExplore/qc/", file_list[i], ".pdf"), height = 8, width=12)
    grid.arrange(p1, p2, p3, ncol = 3)
    dev.off()
    
    ###########################
  #Here is the filtering step
  ############################
  standev <- sd(log(s.obj$nFeature_RNA))*2.5 #cutting off above standard deviation of 2.5
  mean <- mean(log(s.obj$nFeature_RNA))
  cut <- round(exp(standev+mean))
  s.obj <- subset(s.obj, subset = mito.genes < 10 & nFeature_RNA < cut)
    
   ###########################################
  #Estimate Doublets for Each Sequencing Run
  ############################################
  sce <- as.SingleCellExperiment(s.obj)
  sce <- scDblFinder(sce, BPPARAM=MulticoreParam(3))
  doublets <- data.frame(db.weight.score = sce$scDblFinder.score, db.ratio = sce$scDblFinder.weighted, 
                         db.class = sce$scDblFinder.class, db.score = sce$scDblFinder.score)
  rownames(doublets) <- rownames(sce@colData)
  s.obj <- AddMetaData(s.obj, doublets)
  rm(sce)
  
  ####Adding meta data
  directory <- readxl::read_xlsx("./data/sample.directory.xlsx") #Meta.data
  meta <- s.obj[[]]
  rownames <- rownames(meta)
  meta <- merge(meta, directory, by.x = "orig.ident", by.y = "ID")
  meta <- meta[,9:ncol(meta)]
  rownames(meta) <- rownames
  
  
  ## Finding variable features and normalizing data for integration to follow
  s.obj <- AddMetaData(s.obj, meta)
  s.obj <- NormalizeData(s.obj)
  s.obj <- FindVariableFeatures(s.obj, selection.method = "vst", nfeatures = 2000)
  s.obj <- quietTCRgenes(s.obj)
  VariableFeatures(s.obj, assay = "ADT") <- rownames(s.obj[["ADT"]])
  s.obj <- NormalizeData(s.obj, normalization.method = 'CLR', margin = 2, assay = "ADT")

  list[[i]] <- s.obj
}
saveRDS(list, file = "./data/filtered_seuratObjects.rds")
rm(tmp)
rm(adt_assay)
rm(s.obj)
```


## Integrate Assays

```{r}

#####################
#Integrating RNA
###################

# select features that are repeatedly variable across datasets for integration
features <- SelectIntegrationFeatures(object.list = list)

immune.anchors <- FindIntegrationAnchors(object.list = list, anchor.features = features)
# this command creates an 'integrated' data assay
immune.combined <- IntegrateData(anchorset = immune.anchors)
immune.combined <- ScaleData(immune.combined, verbose = FALSE)
immune.combined <- RunPCA(immune.combined, npcs = 30, verbose = FALSE)

saveRDS(immune.combined, file = "./data/RNAintegrated_seuratObjects.rds")
rm(features)
rm(immune.anchors)
rm(immune.combined)


############################
#Integrating ADT
############################
list <- readRDS("./data/filtered_seuratObjects.rds")
features <- rownames(list[[1]][["ADT"]])

list <- lapply(X = list, FUN = function(x) {
    DefaultAssay(x) <- "ADT"
    x <- ScaleData(x, features = features, verbose = FALSE)
    x <- RunPCA(x, features = features, verbose = FALSE)
})

ADT.anchors <- FindIntegrationAnchors(object.list = list, reference = c(1, 2), reduction = "rpca", 
    dims = 1:30, assay = rep("ADT", 14), anchor.features = 37)
ADT.integrated <- IntegrateData(anchorset = ADT.anchors, dims = 1:30)
ADT <- ADT.integrated@assays$integrated
rm(ADT.anchors)
rm(ADT.integrated)

############################
#Combining all to single object
############################
list <- readRDS("./data/RNAintegrated_seuratObjects.rds")
list[["ADT.integrated"]] <- ADT

DefaultAssay(list) <- 'ADT.integrated'
VariableFeatures(list) <- rownames(list[["ADT.integrated"]])
list <-  list %>% 
  ScaleData() %>% RunPCA(reduction.name = 'apca')

saveRDS(list, file = "./data/Fullintegrated_seuratObjects.rds")
```

# Initial UMAP and Clustering

```{r}
list <- readRDS("./data/Fullintegrated_seuratObjects.rds")

list <- FindMultiModalNeighbors(
  list, reduction.list = list("pca", "apca"), 
  dims.list = list(1:30, 1:30), modality.weight.name = "RNA.weight"
)

k <- c(15,20,25,30,35,40,45,50,55,60,65)
dir.create("./dataExplore/keval")
out <- NULL
for(i in k) {
  myClusterFUN <- function(x, k) {
      g <- bluster::makeSNNGraph(x, type="jaccard", k = k)
      igraph::cluster_louvain(g)$membership
  }
  
  pcs <- list@neighbors$weighted.nn@nn.dist
  originals <- myClusterFUN(pcs, i)
  
  set.seed(0010010100)
  ratios <- bluster::bootstrapStability(pcs, FUN=myClusterFUN, k = i, clusters=originals)
  dim(ratios)
  
  pdf(paste0("./dataExplore/keval/Heatmap_Cluster.stability", i, ".pdf"), height = 3, width = 3.25)
  pheatmap::pheatmap(ratios, cluster_row=FALSE, cluster_col=FALSE, fontsize = 4,
      color=viridis::magma(100), breaks=seq(-1, 1, length.out=101))
  dev.off()
  summary <- c(i, mean(diag(ratios), na.rm = TRUE), median(diag(ratios), na.rm = TRUE), sd(diag(ratios), na.rm = TRUE))
  out <- rbind(out, summary)
}
colnames(out) <- c("k", "mean", "median", "stdev")
write.csv(out, "./dataExplore/keval/ClusterPerformance.csv", row.names = FALSE)
```


```{r}
list <- ref_LCMV_Atlas_mouse_v1.rdsAP(list, 
                nn.name = "weighted.nn", 
                reduction.name = "wnn.umap", 
                reduction.key = "wnnUMAP_", 
                n.neighbors = 50)


res <- k <- c(0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.3, 1.4, 1.5)
for (i in seq_along(res)) {
  list <- FindClusters(list, graph.name = "wsnn", algorithm = 3, resolution = res[i], verbose = FALSE)
}
```

Evaluating clustering by resolution using clustree

```{r}
library(clustree)
clustree(list, prefix = "wsnn_res.", layout = "sugiyama")
ggsave("./dataExplore/ClusterTree_resolution.pdf", height = 12, width = 12)

clustree(list, prefix = "wsnn_res.", layout = "sugiyama", node_colour = "sc3_stability")
ggsave("./dataExplore/ClusterTree_stability.pdf", height = 12, width = 12)
```
Selecting the resolution of 0.8 based on the clustree results. 

```{r}
list@meta.data$seurat_clusters <- list@meta.data$wsnn_res.0.8
list@meta.data <- list@meta.data[,-grep("wsnn_res", colnames(list[[]]))]
Idents(list) <- "seurat_clusters"
DimPlot(list, label = TRUE) + NoLegend()
saveRDS(list, file = "./data/Fullintegrated_seuratObjects.rds")
```

# Cell Annotation

## ProjecTIL annotation using the LCMV CD4 and CD8 data sets

```{r}
library(ProjecTILs)
list <- readRDS("./data/Fullintegrated_seuratObjects.rds")
list <- SplitObject(list, split.by = "orig.ident")

###########################
#CD4 LCMV Annotation
############################

ref <- load.reference.map("./data/Annotation/ref_LCMV_CD4_mouse_release_v1.rds")
query.projected <- make.projection(list, ref = ref, ncores = 1, human.ortho = TRUE)

#Lapply across list of Seurat objects
query.projected <- lapply(query.projected, function(x) {
    cellstate.predict(ref = ref, query = x, reduction = "umap", ndim = 2)
})

CD4.annotation <- NULL
#Loop for the meta data
for (i in seq_along(query.projected)) {
  meta <- query.projected[[i]][[c("functional.cluster", "functional.cluster.conf")]]
  colnames(meta) <- c("CD4.annot", "CD4.score")
  rownames(meta) <- stringr::str_remove(rownames(meta), "Q_")
  CD4.annotation <- rbind(CD4.annotation, meta)
}
saveRDS(CD4.annotation,"./data/Annotation/CD4.annotation.rds")
rm(CD4.annotation)
rm(query.projected)

###########################
#CD8 LCMV Annotation
############################

ref <- load.reference.map("./data/Annotation/ref_LCMV_Atlas_mouse_v1.rds")
query.projected <- make.projection(list, ref = ref, ncores = 1, human.ortho = TRUE)

#Lapply across list of Seurat objects
query.projected <- lapply(query.projected, function(x) {
    cellstate.predict(ref = ref, query = x, reduction = "umap", ndim = 2)
})

CD8.annotation <- NULL
#Loop for the meta data
for (i in seq_along(query.projected)) {
  meta <- query.projected[[i]][[c("functional.cluster", "functional.cluster.conf")]]
  colnames(meta) <- c("CD8.annot", "CD8.score")
  rownames(meta) <- stringr::str_remove(rownames(meta), "Q_")
  CD8.annotation <- rbind(CD8.annotation, meta)
}
saveRDS(CD8.annotation,"./data/Annotation/CD8.annotation.rds")
rm(CD8.annotation)
rm(query.projected)
```

## SingleR annotation using the DICE data set
```{r}
library(SingleR)
library(Matrix)
DICE <- DatabaseImmuneCellExpressionData()
DICE.annotation <- NULL
for (i in seq_along(list)) {
  tmp <- list[[i]]
  tmp.2 <- tmp@assays[["RNA"]]@counts
  ####This approach for matrix conversion saves some memory
  tmp.2 <- tmp.2[tabulate(summary(tmp.2)$i) != 0, , drop = FALSE]
  tmp.2 <- as.matrix(tmp.2)
  com.res2 <- SingleR(tmp.2, ref=DICE, labels=DICE$label.fine, assay.type.test=1)
  df <- data.frame("DICE.first.labels" = com.res2$first.labels, "DICE.labels" = com.res2$labels, "DICE.pruned.labels" = com.res2$pruned.labels)
  rownames(df) <- rownames(tmp[[]])
  DICE.annotation <- rbind(DICE.annotation, df)
}
saveRDS(DICE.annotation,"./data/Annotation/DICE.annotation.rds")
```

## Consensus Annotation 

Quickly adding the labeled results from each pipeline. 

```{r}
CD4 <- readRDS("./data/Annotation/CD4.annotation.rds")
CD8 <- readRDS("./data/Annotation/CD8.annotation.rds")
DICE <- readRDS("./data/Annotation/DICE.annotation.rds")

annot <- merge(CD4, CD8, by = 0, all = TRUE)
annot <- merge(annot, DICE, by.x = "Row.names", by.y = 0, all = TRUE)
cells <- annot$Row.names
annot <- annot[,-1]
rownames(annot) <- cells

list <- readRDS("./data/Fullintegrated_seuratObjects.rds")
list <- AddMetaData(list, annot)
saveRDS(list, file = "./data/Fullintegrated_seuratObjects.rds")

library(viridis)
DimPlot(list, group.by = "CD4.annot") + scale_color_manual(values = viridis_pal(option = "H")(length(unique(list$CD4.annot))))

DimPlot(list, group.by = "CD8.annot") + scale_color_manual(values = viridis_pal(option = "H")(length(unique(list$CD8.annot))))

DimPlot(list, group.by = "DICE.pruned.labels") + scale_color_manual(values = viridis_pal(option = "H")(length(unique(list$DICE.pruned.labels))))
```

## Adding contig data to the Seurat object
```{r}
library(scRepertoire)
file_list <- list.files("./data/SequencingRuns", pattern = "Sar")
######################################
#iterate to make a list of contig csvs
######################################


contig.list <- NULL
for (i in seq_along(file_list)){
  contig.list[[i]] <-  read.csv(paste0("./data/SequencingRuns/", file_list[i], "/contig_annotations.csv"))
}
names(contig.list) <- file_list

##################################################
#Reducing the data to the individual barcode level
##################################################
combinedObject <- combineTCR(contig.list, samples = file_list, filterMulti = TRUE, removeNA = TRUE, cells = "T-AB")
combinedObject <- addVariable(combinedObject, name = "Patient", variables = substr(file_list, 1,5))
list <- combineExpression(combinedObject, list, cloneCall = "aa", group.by = "Patient")

slot(list, "meta.data")$cloneType <- factor(slot(list, "meta.data")$cloneType, 
                levels = c("Hyperexpanded (0.1 < X <= 1)", 
                           "Large (0.01 < X <= 0.1)", 
                            "Medium (0.001 < X <= 0.01)", 
                            "Small (1e-04 < X <= 0.001)", 
                            "Rare (0 < X <= 1e-04)", NA))

DimPlot(list, group.by = "cloneType") + scale_color_manual(values = rev(viridis_pal(option = "B")(length(unique(list$cloneType)))))

saveRDS(list, file = "./data/Fullintegrated_seuratObjects.rds")
```




## Simplify Clusters 

There are 11 clusters with 2 or less cells - the following removes them and renumbers the clustering 

```{r}
list <- subset(list, idents = names(which(table(list$seurat_clusters) > 10)))

list$seurat_clusters <- droplevels(list$seurat_clusters)
list$seurat_clusters <- paste0("C", as.numeric(list$seurat_clusters))
Idents(list) <- "seurat_clusters"

Idents(list) <- factor(Idents(list), levels = paste0("C", 1:33))

DimPlot(list, label = TRUE)  + scale_color_manual(values = viridis_pal(option = "H")(length(unique(list$seurat_clusters)))) + theme_void() + NoLegend() 
ggsave("UMAP_clusters.png", dpi = 600, height = 3.5, width = 3.5)
saveRDS(list, file = "./data/Fullintegrated_seuratObjects.rds")
```
## Graphing canonical marker genes

```{r}
dir.create("./output/LineageMarkers")
file_list <- list.files("./data/markers.genes")
file_list <- file_list[grepl(".txt", file_list)]
files <- file.path(paste0("./data/markers.genes/", file_list))
marker_list <- list()
for (i in 1:length(files)) {
    marker_list[[i]] <- read.delim(paste0(files[i]), col.names = FALSE)
    for (j in seq_len(nrow(marker_list[[i]]))) {
      marker_list[[i]][j,] <- toupper( marker_list[[i]][j,])
    }
}
names <- stringr::str_remove(file_list, ".txt")
names(marker_list) <- names

suppressPackageStartupMessages(library(schex))
list <- make_hexbin(list, 128, dimension_reduction = "wnn.umap")
DefaultAssay(list) <- "RNA"

dir.create("./output/LineageMarkers")
for (i in seq_along(marker_list)) {
    tmp <- as.character(unlist(marker_list[i]))
    for (j in seq_along(tmp)) {
        if (length(which(rownames(list@assays$RNA@counts) == tmp[j])) == 0){
            next() #Need to loop here because plot_hexbin_feature() does not have a built-in function to deal with absence of selected gene
        } else {
        plot <- plot_hexbin_feature(list, feature = tmp[j], type = "counts", action = "prop_0")+ 
             guides(fill="none", color = "none") + 
                scale_fill_viridis(option = "B") 
        ggsave(path = "./output/LineageMarkers", file = paste0(names(marker_list)[i], "_", tmp[j], "_prop.pdf"), plot, height=3, width=3.25)
        }
    }
}

DefaultAssay(list) <- "ADT"
tmp <- rownames(list@assays$ADT@counts)

for (j in seq_along(tmp)) {
        plot <- plot_hexbin_feature(list, feature = tmp[j], type = "data", mod = "ADT", action = "median")+ 
             guides(fill="none", color = "none") + 
                scale_fill_viridis(option = "B") 
        ggsave(path = "./output/LineageMarkers", file = paste0(tmp[j], "_prop.pdf"), plot, height=3, width=3.25)
        }
```

## Consensus Clustering
```{r}
list <- readRDS("./data/Fullintegrated_seuratObjects.rds")

DefaultAssay(list) <- "ADT"
FeaturePlot(list, features = "CD8-TotalSeqC") + 
  scale_color_viridis(option = "B")

hist(list@assays$ADT@data["CD8-TotalSeqC",], breaks = 100)

list@meta.data$CD8.ADT <- ifelse(list@assays$ADT@data["CD8-TotalSeqC",] >=  1.25, "Yes", "No")
list@meta.data$CD4.annot.mod <- list@meta.data$CD4.annot
list@meta.data$CD4.annot.mod <- ifelse(list@meta.data$CD8.ADT == "Yes", NA, list@meta.data$CD4.annot.mod)
list@meta.data$CD8.annot.mod <- list@meta.data$CD8.annot
list@meta.data$CD8.annot.mod <- ifelse(list@meta.data$CD8.ADT == "No", NA, list@meta.data$CD8.annot.mod)
```

```{r}
df <- as.data.frame(list@reductions$wnn.umap@cell.embeddings)
meta <- list[[]]

xmin <- round(min(df$wnnUMAP_1)-1)
xmax <- round(max(df$wnnUMAP_1)+1)

ymin <- round(min(df$wnnUMAP_2)-1)
ymax <- round(max(df$wnnUMAP_2)+1)

basePlot <- ggplot(df, aes(x = wnnUMAP_1, y = wnnUMAP_2)) + 
  geom_point(col = "grey", stroke = 0) + 
  theme_void() + 
  xlim(xmin, xmax) + 
  ylim(ymin, ymax)

types <- sort(unique(list$CD4.annot.mod))
for (i in seq_along(types)) {
  tmp <- which(meta$CD4.annot.mod == types[i])
  plot <- basePlot + 
    stat_density_2d(df[tmp,], mapping = aes(x = wnnUMAP_1, 
                              y = wnnUMAP_2, fill = stat(level)),
                        geom = "polygon", 
                    bins = 20) + 
    theme_void() + 
    scale_fill_viridis(option = "B") + 
    guides(fill = "none")  + 
    ggtitle(types[i])
  assign(types[i], plot)
}

library(patchwork) 
#paste(types, collapse = "+")
Eomes_HI+INFI_stimulated+Tcm+Tcmp+Tfh_Effector+Tfh_Memory+Th1_Effector+Th1_Memory+Treg
ggsave("CD4.ProjecTIL.annotation.mod.png", height = 9, width = 10, dpi = 600)

types <- sort(unique(list$CD8.annot.mod))
for (i in seq_along(types)) {
  tmp <- which(meta$CD8.annot.mod == types[i])
  plot <- basePlot + 
    stat_density_2d(df[tmp,], mapping = aes(x = wnnUMAP_1, 
                              y = wnnUMAP_2, fill = stat(level)),
                        geom = "polygon", 
                    bins = 20) + 
    theme_void() + 
    scale_fill_viridis(option = "B") + 
    guides(fill = "none")  + 
    ggtitle(types[i])
  assign(types[i], plot)
}

#paste(types, collapse = "+")
`Eff Cycling`+`Eff Early`+`Eff Interm`+`Memory Prec`+SLEC+Tex+Tpex
ggsave("CD8.ProjecTIL.annotation.mod.png", height = 9, width = 10, dpi = 600)

types <- sort(unique(list$DICE.pruned.labels))
names <- stringr::str_remove_all(types, " ")
names <- stringr::str_remove_all(names, "[+]")
names <- stringr::str_replace_all(names, ",", ".")
for (i in seq_along(types)) {
  tmp <- which(meta$DICE.labels == types[i])
  plot <- basePlot + 
    stat_density_2d(df[tmp,], mapping = aes(x = wnnUMAP_1, 
                              y = wnnUMAP_2, fill = stat(level)),
                        geom = "polygon", 
                    bins = 20) + 
    theme_void() + 
    scale_fill_viridis(option = "B") + 
    guides(fill = "none")  + 
    ggtitle(types[i])
  assign(names[i], plot)
}

paste(names, collapse = "+")
Bcells.naive+Monocytes.CD14+Monocytes.CD16+NKcells+Tcells.CD4.memoryTREG+Tcells.CD4.naive+Tcells.CD4.naiveTREG+Tcells.CD4.naive.stimulated+Tcells.CD4.TFH+Tcells.CD4.Th1+Tcells.CD4.Th1_17+Tcells.CD4.Th17+Tcells.CD4.Th2+Tcells.CD8.naive+Tcells.CD8.naive.stimulated + plot_layout(ncol = 3)
ggsave("DICE.annotation.png", height = 15, width = 10, dpi = 600)
```


```{r}
meta <- list[[]]

tissue <- table(list$Tissue, list$seurat_clusters, useNA = "ifany")
for (i in 1:2) {
  tissue[i,] <- tissue[i,]/sum(tissue[i,])
}
tissue <- as.data.frame(tissue)
tissue$Var2 <- factor(tissue$Var2, levels = paste0("C", 1:33))
ggplot(tissue, aes(x = Var2, fill = Var1, y = Freq)) + 
  geom_bar(stat = "identity", position = "fill") + 
  geom_hline(yintercept = 0.5) + 
  geom_hline(yintercept = c(0.4, 0.6), lty = 2) + 
  coord_flip() +
  theme_classic() + 
  scale_fill_manual(values = rev(viridis_pal(option = "F")(4)))


CD4.annot <- table(list$CD4.annot.mod, list$seurat_clusters, useNA = "ifany")
for (i in seq_len(nrow(CD4.annot))) {
  CD4.annot[,i] <- CD4.annot[,i]/sum(CD4.annot[,i])
}
CD4.annot <- as.data.frame(CD4.annot)
CD4.annot$Var2 <- factor(CD4.annot$Var2, levels = paste0("C", 1:33))

ggplot(CD4.annot, aes(x = Var2, fill = Var1, y = Freq)) + 
  geom_bar(stat = "identity", position = "fill") + 
  geom_hline(yintercept = 0.5) + 
  geom_hline(yintercept = c(0.4, 0.6), lty = 2) + 
  coord_flip() +
  theme_classic() +
  labs(fill = "CellType") + 
  scale_fill_manual(values = rev(viridis_pal(option = "H")(length(unique(CD4.annot$Var1)))))+ 
  theme(axis.title = element_blank())
ggsave("CD4.mod.distribution.pdf", height = 4, width = 5)


CD8.annot <- table(list$CD8.annot.mod, list$seurat_clusters, useNA = "ifany")
for (i in seq_len(nrow(CD8.annot))) {
  CD8.annot[,i] <- CD8.annot[,i]/sum(CD8.annot[,i])
}
CD8.annot <- as.data.frame(CD8.annot)
CD8.annot$Var2 <- factor(CD8.annot$Var2, levels = paste0("C", 1:33))

ggplot(CD8.annot, aes(x = Var2, fill = Var1, y = Freq)) + 
  geom_bar(stat = "identity", position = "fill") + 
  geom_hline(yintercept = 0.5) + 
  geom_hline(yintercept = c(0.4, 0.6), lty = 2) + 
  coord_flip() +
  theme_classic() +
  labs(fill = "CellType") + 
  scale_fill_manual(values = rev(viridis_pal(option = "H")(length(unique(CD8.annot$Var1)))))+ 
  theme(axis.title = element_blank())
ggsave("CD8.mod.distribution.pdf", height = 4, width = 5)
```


## ImmunoMind Annotation

```{r}
Helper <- readxl::read_xlsx("./data/Annotation/ImmunoMind/IM_helper.xlsx")
names <- Helper$Marker
Helper <- as.data.frame(Helper[,-1])
rownames(Helper) <- names

Major <- readxl::read_xlsx("./data/Annotation/ImmunoMind/IM_major.xlsx")
names <- Major$Marker
Major <- as.data.frame(Major[,-1])
rownames(Major) <- names

```


```{r}
DefaultAssay(list) <- "RNA"
markers <- FindAllMarkers(list)
write.csv(markers, "FindAllMarkers.csv")
markers <- read.csv("FindAllMarkers.csv")

unwanted_genes <- "TRBV*|^TRBD*|^TRBJ*|^TRDV*|^TRDD*|^TRDJ*|^TRAV*|^TRAJ*|^TRGV*|^TRGJ*|^MT-*|^RPS*|^RPL*"
markers2 <- markers[!grepl(pattern = unwanted_genes, x = markers$gene),]

top50 <- markers2 %>%
  group_by(cluster) %>%
  top_n(50, avg_log2FC)
```

```{r}
annotation <- Helper
markers <- top50

#sc is the single-cell object, right now it is formated only for Seurat
#markers is the filter top x output from FindMarkers
#annotation is the annotation file provided in excel
IM.score <- function(sc, markers, annotation) {
  annotation.list <- list()
  #make FindMarker object into list
  marker.list <- split(markers, markers[,"cluster"])
  #Make annotation lists for each subtype
  for (x in seq_len(ncol(annotation))) { 
    full <- rownames(annotation)[which(annotation[,x] == 1)]
    half <- rownames(annotation)[which(annotation[,x] == 0.5)]
    tmp <- list(full, half)
    annotation.list[[x]] <- tmp
  }
  names(annotation.list) <- colnames(annotation)
  score.matrix <- matrix(nrow = length(marker.list), ncol = length(annotation.list), 0)
  #Loop through the annotation scoring 
  #Score is scaled by the total number of genes in the annotated cell type that is expressed in the count data
  for (y in seq_along(marker.list)) {
    for(z in seq_along(annotation.list)) {
      full.denominator <- rownames(sc@assays$RNA@counts)[rownames(sc@assays$RNA@counts) %in% annotation.list[[z]][[1]]]
      if(length(full.denominator) == 0) {
        full.denominator <- 1
      }
      half.denominator <- rownames(sc@assays$RNA@counts)[rownames(sc@assays$RNA@counts) %in% annotation.list[[z]][[2]]]
      if(length(half.denominator) == 0) {
        half.denominator <- 1
      }
      full.score <- length(which(marker.list[[y]]$gene %in% annotation.list[[z]][[1]]))/length(full.denominator)
      half.score <- length(which(marker.list[[y]]$gene %in% annotation.list[[z]][[2]]))/length(half.denominator)
      total.score <- full.score + half.score/2
      score.matrix[y,z] <- total.score
    }
  }
  colnames(score.matrix) <- names(annotation.list)
  rownames(score.matrix) <- names(marker.list)
  return(score.matrix)
}

scores.major <- IM.score(list,top50, Major)
pheatmap::pheatmap(scores.major, cluster_rows = FALSE, color = viridis_pal()(50))

scores.helper <- IM.score(list,top50, Helper)
pheatmap::pheatmap(scores.helper, cluster_rows = FALSE, color = viridis_pal()(50))
```



```{r}
library(Seurat)
library(dplyr)
library(Trex)
list <- readRDS("./data/Fullintegrated_seuratObjects.rds")
cells.chains <- rownames(list[[]][!is.na(list[["cloneType"]]),])
Tcells <- subset(list, cells = cells.chains)

cells.chains <- rownames(Tcells[[]][!is.na(Tcells[["CD4.annot"]]),])
Tcells <- subset(Tcells, cells = cells.chains)

Tcells <- DietSeurat(Tcells, assays = c("RNA", "ADT"))
DefaultAssay(Tcells) <- "RNA"
list <- SplitObject(Tcells, "orig.ident")

#############################################################
#Calculating Variable Genes and Removing TCR-related genes
############################################################
list <- lapply(X = list, FUN = function(x) {
    x <- NormalizeData(x)
    x <- FindVariableFeatures(x, selection.method = "vst", nfeatures = 2000)
    x <- quietTCRgenes(x)
})

  
#####################
#Integrating RNA
###################

# select features that are repeatedly variable across datasets for integration
features <- SelectIntegrationFeatures(object.list = list)

immune.anchors <- FindIntegrationAnchors(object.list = list, anchor.features = features)
# this command creates an 'integrated' data assay
immune.combined <- IntegrateData(anchorset = immune.anchors)
immune.combined <- ScaleData(immune.combined, verbose = FALSE)
immune.combined <- RunPCA(immune.combined, npcs = 30, verbose = FALSE)

saveRDS(immune.combined, file = "./data/RNAintegrated_Tcell_seuratObjects.rds")
rm(features)
rm(immune.anchors)
rm(immune.combined)

DefaultAssay(list[[1]])
############################
#Integrating ADT
############################
DefaultAssay(Tcells) <- "ADT"
list <- SplitObject(Tcells, "orig.ident")
features <- rownames(list[[1]][["ADT"]])

list <- lapply(X = list, FUN = function(x) {
    DefaultAssay(x) <- "ADT"
    x <- ScaleData(x, features = features, verbose = FALSE)
    x <- RunPCA(x, features = features, verbose = FALSE)
})

ADT.anchors <- FindIntegrationAnchors(object.list = list, reference = c(1, 2), reduction = "rpca", 
    dims = 1:30, assay = rep("ADT", 14), anchor.features = 37)
ADT.integrated <- IntegrateData(anchorset = ADT.anchors, dims = 1:30)
ADT <- ADT.integrated@assays$integrated
rm(ADT.anchors)
rm(ADT.integrated)

############################
#Combining all to single object
############################
list <- readRDS("./data/RNAintegrated_Tcell_seuratObjects.rds")
list[["ADT.integrated"]] <- ADT

DefaultAssay(list) <- 'ADT.integrated'
VariableFeatures(list) <- rownames(list[["ADT.integrated"]])
list <-  list %>% 
  ScaleData() %>% RunPCA(reduction.name = 'apca')

saveRDS(list, file = "./data/Fullintegrated_Tcell_seuratObjects.rds")

```

```{r}
list <- readRDS("./data/Fullintegrated_Tcell_seuratObjects.rds")

RNA.neighbors <- FindNeighbors(list@reductions$pca@cell.embeddings, 
                               annoy.metric = "cosine", 
                               k.param = 30)
saveRDS(RNA.neighbors, "RNA.neighbors.rds")
ADT.neighbors <- FindNeighbors(list@reductions$apca@cell.embeddings, 
                               annoy.metric = "cosine", 
                               k.param = 30)
saveRDS(ADT.neighbors, "ADT.neighbors.rds")

meta <- list[[]]
saveRDS(meta, "Tcell.meta.rds")


```



